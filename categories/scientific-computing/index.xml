<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scientific Computing on Journeyman Modeler</title>
    <link>/categories/scientific-computing/</link>
    <description>Recent content in Scientific Computing on Journeyman Modeler</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 May 2021 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/categories/scientific-computing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Explaining the Dirichlet Draws Function</title>
      <link>/post/2021-05-02-explaining-the-dirichlet-draws-function/</link>
      <pubDate>Sun, 02 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021-05-02-explaining-the-dirichlet-draws-function/</guid>
      <description>
&lt;script src=&#34;../../rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;This post is a continuation of the post that discusses the &lt;a href=&#34;https://jmodeler.github.io/post/2021-04-25-dirichlet-distribution-draws-function-with-rcpp-rcpparmadillo/&#34;&gt;dirichlet draws function&lt;/a&gt;. In this post I explain the function step by step, starting with the header files used:&lt;/p&gt;
&lt;div id=&#34;step-1-headers-needed&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 1: Headers Needed&lt;/h2&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;RcppArmadillo.h&amp;gt;
// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;

// [[Rcpp::export]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As explained very well by &lt;a href=&#34;https://archive.fo/LwLVs&#34;&gt;Matt Denny&lt;/a&gt; &lt;a href=&#34;https://archive.fo/wCMHo&#34;&gt;here&lt;/a&gt;, this part of the code lets the compiler know where to look for the constructs being used in the body of the function. In addition, the “&lt;span class=&#34;math inline&#34;&gt;\(\texttt{//[[Rcpp::export]]}\)&lt;/span&gt;” statement makes the compiled function available for use in R.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-2-function-definition&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 2: Function Definition&lt;/h2&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;arma::mat rdirichlet_cpp(int n, arma::vec concentration_parameters) {
  // get n random draws from the dirichlet distribution
  // n: number of draws needed
  // concentration_parameters: self explanatory, needed parameters for the dirichlet
  // distribution
  // create a variable to store the length of the concentration_parameters vector&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, I’m creating the rdirichlet_cpp() function, that returns an armadillo matrix object, and takes an integer “n”, and an armadillo vector named “concentration_parameters”. These variables are described in a little more detail in the comments of the function. “n” contains the number of draws needed from the dirichlet distribution, while “concentration_parameters” is a vector containing values &lt;span class=&#34;math inline&#34;&gt;\(&amp;gt;0\)&lt;/span&gt;, described in detail &lt;a href=&#34;https://en.wikipedia.org/wiki/Dirichlet_distribution#The_concentration_parameter&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-3-function-body-variable-declarations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 3: Function Body: Variable Declarations&lt;/h2&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;int k = concentration_parameters.n_elem;
  // next, create a matrix that will store the gamma draws
  // each row in this matrix will be a draw from the gamma distribution
  arma::mat gamma_draws(n, k, arma::fill::zeros);
  // create a matrix that stores the dirichlet distribution draws
  arma::mat dirichlet_draws(n, k, arma::fill::zeros);
  // create temporary variables that will store values in the loops
  // vector to store temporary gamma draws
  NumericVector temp_gamma(n);
  // variable to store the column sums of the gamma_draws matrix
  arma::vec temp_sum;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I create the following variables here:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;k: this contains the length of the concentration_parameters variable.&lt;/li&gt;
&lt;li&gt;gamma_draws: this is an armadillo matrix of size &lt;span class=&#34;math inline&#34;&gt;\(n \,\, \times \,\, k\)&lt;/span&gt;, that will store draws from Rcpp’s &lt;span class=&#34;math inline&#34;&gt;\(\texttt{rgamma()}\)&lt;/span&gt; function. All of its elements are currently initialized to &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;dirichlet_draws: this is an armadillo matrix of size &lt;span class=&#34;math inline&#34;&gt;\(n \,\, \times \,\, k\)&lt;/span&gt;, that will store draws from the dirichlet distribution needed. All of its elements are currently initialized to &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;temp_gamma: this is an Rcpp &lt;span class=&#34;math inline&#34;&gt;\(\texttt{NumericVector}\)&lt;/span&gt;, that temporarily stores draws from the &lt;span class=&#34;math inline&#34;&gt;\(\texttt{rgamma()}\)&lt;/span&gt; function.&lt;/li&gt;
&lt;li&gt;temp_sum: this is an armadillo vector that contains the row sums of the “filled-out” gamma_draws matrix (will be explained in the next step).&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;step-4-function-body-generate-gamma-draws&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 4: Function Body: Generate Gamma Draws&lt;/h2&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt; // now, loop across the concentration parameters
  // get gamma draws and fill up the gamma_draws matrix
  for(int ii = 0; ii &amp;lt; k; ii++) {
    // get draws from gamma distribution, store in an armadillo vector
    temp_gamma = rgamma(n, concentration_parameters.at(ii));
    // temp_gamma is an Rcpp NumericVector, which needs to be converted into an armadillo vector and then
    // stored in the gamma_draws matrix
    gamma_draws.col(ii) = as&amp;lt;arma::vec&amp;gt;(temp_gamma);
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this part of the function body, I do the following:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;I create a for loop to traverse through values &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\((k-1)\)&lt;/span&gt; (via variable &lt;span class=&#34;math inline&#34;&gt;\(ii\)&lt;/span&gt;).&lt;/li&gt;
&lt;li&gt;I extract the concentration parameter at the &lt;span class=&#34;math inline&#34;&gt;\(ii^{th}\)&lt;/span&gt; location, and get &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;, draws from Rcpp’s &lt;span class=&#34;math inline&#34;&gt;\(\texttt{rgamma()}\)&lt;/span&gt;, function and then store it in temp_gamma.&lt;/li&gt;
&lt;li&gt;I convert temp_gamma from a &lt;span class=&#34;math inline&#34;&gt;\(\texttt{NumericVector}\)&lt;/span&gt; to an armadillo vector object, and then store it in the &lt;span class=&#34;math inline&#34;&gt;\(ii^{th}\)&lt;/span&gt; column of the gamma_draws matrix. This is how I “fill-out” the gamma_draws matrix.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;step-5-function-body-generate-dirichlet-draws&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 5: Function Body: Generate Dirichlet Draws&lt;/h2&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;  // now normalize the rows to get the dirichlet draws
  // element-wise normalization using the each_col() method for a matrix object in armadillo
  // create the vector of row sums
  temp_sum = arma::sum(gamma_draws, 1);
  // now divide each column of gamma_draws with the elements in temp_sum
  dirichlet_draws = gamma_draws.each_col() / temp_sum;
  // return this final value
  return dirichlet_draws;
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, I now do the following:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;I calculate the row sums of the gamma_draws (which has been “filled-out” in step 4 above) function using the &lt;span class=&#34;math inline&#34;&gt;\(\texttt{sum}\)&lt;/span&gt; function from the armadillo library, storing the results in temp_sum.&lt;/li&gt;
&lt;li&gt;I now apply a &lt;a href=&#34;http://arma.sourceforge.net/docs.html#each_colrow&#34;&gt;vector operation&lt;/a&gt; to each column of the gamma_draws matrix by the temp_sum vector, where each column of the gamma_draws matrix is divided by each corresponding element of the temp_sum vector. I store the results in the armadillo matrix dirichlet_draws.&lt;/li&gt;
&lt;li&gt;I return the dirichlet_draws matrix as the final output.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>The Homotopy Principle: Simple Examples</title>
      <link>/post/the-homotopy-principle-simple-examples/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/the-homotopy-principle-simple-examples/</guid>
      <description>


&lt;p&gt;This post presents 2 simple examples of the homotopy principle applied to (fairly easy) linear and nonlinear systems of equations. At a very abstract level, given a system of equations for which a solution is needed, we convert this system to one whose solution we already know (or is easy to find out), and then bend this system till we get the solution to the original set of equations. These methods have very broad applications &lt;span class=&#34;citation&#34;&gt;(Garcia and Zangwill &lt;a href=&#34;#ref-garciapathways&#34; role=&#34;doc-biblioref&#34;&gt;1981&lt;/a&gt;)&lt;/span&gt;, and have been applied in the context of finding equlibria in Static Games &lt;span class=&#34;citation&#34;&gt;(Bajari et al. &lt;a href=&#34;#ref-Bajari2010&#34; role=&#34;doc-biblioref&#34;&gt;2010&lt;/a&gt;)&lt;/span&gt; and Dynamic Games &lt;span class=&#34;citation&#34;&gt;(Borkovsky, Doraszelski, and Kryukov &lt;a href=&#34;#ref-Borkovsky2010&#34; role=&#34;doc-biblioref&#34;&gt;2010&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;div id=&#34;example-1-linear-system&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example 1: Linear System&lt;/h2&gt;
&lt;p&gt;Say we want to find the solution to the following system of linear equations:
&lt;span class=&#34;math display&#34; id=&#34;eq:linEx1&#34;&gt;\[\begin{align}
\left[ \begin{array}
{rrrrr}
1 &amp;amp; 2   \\
3 &amp;amp; 4   \\
\end{array}\right] \left[ \begin{array} {r} 
x_1 \\
x_2 \\
\end{array} \right] = \left[ \begin{array} {l} 
5 \\
11 \\
\end{array} \right] \tag{1} 
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Readers should very easily be able to verify that the unique solution to this system is
&lt;span class=&#34;math display&#34;&gt;\[
(x_1,x_2) = (1,2)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Let’s convert this system and introduce an additional parameter &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, called the &lt;em&gt;homotopy parameter&lt;/em&gt;, which varies from &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;. Let’s call this new system &lt;span class=&#34;math inline&#34;&gt;\(H(x_1, x_2, t)\)&lt;/span&gt;
&lt;span class=&#34;math display&#34; id=&#34;eq:HFunc&#34;&gt;\[\begin{align}
\left[ \begin{array}
{rr}
1 &amp;amp; 2   \\
3 &amp;amp; 4   \\
\end{array}\right] \left[ \begin{array} {r} 
x_1 \\
x_2 \\
\end{array} \right] = \left[ \begin{array} {l} 
5t \\
11t \\
\end{array} \right] \tag{2} 
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When &lt;span class=&#34;math inline&#34;&gt;\(t=0\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(H(x_1, x_2, 0)\)&lt;/span&gt; yields the trivial (and only) solution &lt;span class=&#34;math inline&#34;&gt;\((x_1,x_2) = (0,0)\)&lt;/span&gt;. When &lt;span class=&#34;math inline&#34;&gt;\(t=1\)&lt;/span&gt;, we get our original system of equations back. When we solve for &lt;span class=&#34;math inline&#34;&gt;\((x_1, x_2)\)&lt;/span&gt; as a function of &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, we get:
&lt;span class=&#34;math display&#34;&gt;\[
(x_1(t),x_2(t)) = (t,2t)
\]&lt;/span&gt;
At &lt;span class=&#34;math inline&#34;&gt;\(t=1\)&lt;/span&gt;, this will give us the solution we desire. Tracing the path of the solution gives us the following plots:
&lt;img src=&#34;../../post/2020-04-26-the-homotopy-principle-simple-examples_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-04-26-the-homotopy-principle-simple-examples_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-04-26-the-homotopy-principle-simple-examples_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;From this very simple example, we note that the general process followed is given below &lt;span class=&#34;citation&#34;&gt;(Garcia and Zangwill &lt;a href=&#34;#ref-garciapathways&#34; role=&#34;doc-biblioref&#34;&gt;1981&lt;/a&gt;)&lt;/span&gt;:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Convert the system of equations into one that has a known solution (i.e. &lt;span class=&#34;math inline&#34;&gt;\(H(x_1, x_2, 0)\)&lt;/span&gt; case above)&lt;/li&gt;
&lt;li&gt;Introduce a new parameter &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, that gives the known system at &lt;span class=&#34;math inline&#34;&gt;\(t=0\)&lt;/span&gt; and the system for which the solutions are desired when &lt;span class=&#34;math inline&#34;&gt;\(t=1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Trace the path of the solutions by changing the value of &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; from &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;example-2-nonlinear-system&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example 2: Nonlinear System&lt;/h2&gt;
&lt;p&gt;Consider the following system of equations (from chapter 1, exercise 6 of &lt;span class=&#34;citation&#34;&gt;(Garcia and Zangwill &lt;a href=&#34;#ref-garciapathways&#34; role=&#34;doc-biblioref&#34;&gt;1981&lt;/a&gt;)&lt;/span&gt;):
&lt;span class=&#34;math display&#34; id=&#34;eq:nonlinEx1&#34;&gt;\[\begin{align}
F(x_1, x_2) = 
\left[ \begin{array}
{l}
e^{2 x_1} - x^{2}_{2} + 3   \\
4x_{2}e^{2 x_1} - x^{3}_{2}   \\
\end{array} \right]
 = \left[ \begin{array} {l} 
0 \\
0 \\
\end{array} \right] \tag{3} \\
(x_1, x_2) \in \mathbb{R}^2 \\
F: \mathbb{R}^2 \rightarrow \mathbb{R}^2
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Again, readers should verify that the solutions to this system of equations are &lt;span class=&#34;math inline&#34;&gt;\((x1, x2) = (0, -2) \, \&amp;amp; \, (x1, x2) = (0, 2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We now introduce the homotopy parameter &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, and define &lt;span class=&#34;math inline&#34;&gt;\(H(x_1, x_2, t)\)&lt;/span&gt; as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34; id=&#34;eq:HfuncNonlin1&#34;&gt;\[\begin{align}
H(x_1, x_2, t) = F(x_1, x_2) - (1-t)F(0, 0) \tag{4}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The formulation in &lt;a href=&#34;#eq:HfuncNonlin1&#34;&gt;(4)&lt;/a&gt; is called the &lt;em&gt;Newton Homotopy&lt;/em&gt; &lt;span class=&#34;citation&#34;&gt;(Garcia and Zangwill &lt;a href=&#34;#ref-garciapathways&#34; role=&#34;doc-biblioref&#34;&gt;1981&lt;/a&gt;)&lt;/span&gt;. A distinct advantage of this formulation, is that at &lt;span class=&#34;math inline&#34;&gt;\(t=0\)&lt;/span&gt;, it is easy to see that the solution to the system is &lt;span class=&#34;math inline&#34;&gt;\((0, 0)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;For any &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; between &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(H(x_1, x_2, t)\)&lt;/span&gt; becomes:
&lt;span class=&#34;math display&#34; id=&#34;eq:HfuncNonlin2&#34;&gt;\[\begin{align}
\left[ \begin{array}
{l}
e^{2 x_1} - x^{2}_{2} + 4t - 1   \\
4x_{2}e^{2 x_1} - x^{3}_{2}   \\
\end{array} \right]
 = \left[ \begin{array} {l} 
0 \\
0 \\
\end{array} \right] 
\tag{5}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We now attempt to find &lt;span class=&#34;math inline&#34;&gt;\((x_1, x_2)\)&lt;/span&gt; as functions of &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;. From &lt;a href=&#34;#eq:HfuncNonlin2&#34;&gt;(5)&lt;/a&gt;, we have:
&lt;span class=&#34;math display&#34; id=&#34;eq:x2Sol&#34;&gt;\[\begin{align}
  x_{2}^{3} = 4x_{2}e^{2 x_1} \nonumber \\
  x_2 = 0 \,\,\,\,\, OR \,\,\,\,\, x_{2} = \pm 2e^{x_1} \tag{6}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When &lt;span class=&#34;math inline&#34;&gt;\(x_2 = 0\)&lt;/span&gt;, putting this back in &lt;a href=&#34;#eq:HfuncNonlin2&#34;&gt;(5)&lt;/a&gt; we get:
&lt;span class=&#34;math display&#34; id=&#34;eq:x1Sol1&#34;&gt;\[\begin{align}
  e^{2 x_1} + 4t - 1 = 0 \nonumber \\
  \implies x_1 = \frac{1}{2} log(1-4t) \tag{7} \\
  where \,\,\,\, 0 \le t \le 1/4
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When &lt;span class=&#34;math inline&#34;&gt;\(x_2 = \pm 2e^{x_1}\)&lt;/span&gt;, putting this back in &lt;a href=&#34;#eq:HfuncNonlin2&#34;&gt;(5)&lt;/a&gt; we get:
&lt;span class=&#34;math display&#34; id=&#34;eq:x1Sol2&#34;&gt;\[\begin{align}
  -3e^{2 x_1} + 4t - 1 = 0 \nonumber \\
  \implies x_1 = \frac{1}{2} log\left(\frac{4t-1}{3}\right) \tag{8} \\
  where \,\,\,\, 1/4 &amp;lt; t \le 1
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Combining all the findings from &lt;a href=&#34;#eq:x2Sol&#34;&gt;(6)&lt;/a&gt;, &lt;a href=&#34;#eq:x1Sol1&#34;&gt;(7)&lt;/a&gt; and &lt;a href=&#34;#eq:x1Sol2&#34;&gt;(8)&lt;/a&gt;, we get:
&lt;span class=&#34;math display&#34; id=&#34;eq:x2t&#34; id=&#34;eq:x1t&#34;&gt;\[\begin{align}
  x_1(t) = \begin{cases}
        \frac{1}{2} log(1-4t) &amp;amp; \text{for } 0\le t \le 1/4\\
        \frac{1}{2} log\left(\frac{4t-1}{3}\right) &amp;amp; \text{for } 1/4 &amp;lt; t \leq 1
        \end{cases} \tag{9} \\
    x_1(t) = \begin{cases}
        0 &amp;amp; \text{for } 0\le t \le 1/4\\
        \pm 2 \sqrt{\left(\frac{4t-1}{3}\right)} &amp;amp; \text{for } 1/4 &amp;lt; t \leq 1
        \end{cases} \tag{10}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Which gives us the solution to the system of equations in &lt;a href=&#34;#eq:nonlinEx1&#34;&gt;(3)&lt;/a&gt; at &lt;span class=&#34;math inline&#34;&gt;\(t = 1\)&lt;/span&gt;. However, note that the functions &lt;span class=&#34;math inline&#34;&gt;\(x_1(t), x_2(t)\)&lt;/span&gt; are non-differentiable, which disqualifies them from being solution paths &lt;span class=&#34;citation&#34;&gt;(Garcia and Zangwill &lt;a href=&#34;#ref-garciapathways&#34; role=&#34;doc-biblioref&#34;&gt;1981&lt;/a&gt;)&lt;/span&gt;. This is evident in the plots shown below:
&lt;img src=&#34;../../post/2020-04-26-the-homotopy-principle-simple-examples_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-04-26-the-homotopy-principle-simple-examples_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;One could always try another formulation for &lt;span class=&#34;math inline&#34;&gt;\(H(x_1, x_2, t)\)&lt;/span&gt; which leads to well defined paths to the desired solution from the known solution (i.e. the solution to &lt;span class=&#34;math inline&#34;&gt;\(H(x_1, x_2, 0)\)&lt;/span&gt;). That is left as an exercise to the reader.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Bajari2010&#34;&gt;
&lt;p&gt;Bajari, Patrick, Han Hong, John Krainer, and Denis Nekipelov. 2010. “Computing Equilibria in Static Games of Incomplete Information Using the All-Solution Homotopy.” &lt;em&gt;Operations Research&lt;/em&gt; 58 (4-part 2).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Borkovsky2010&#34;&gt;
&lt;p&gt;Borkovsky, Ron N., Ulrich Doraszelski, and Yaroslav Kryukov. 2010. “A user’s guide to solving dynamic stochastic games using the homotopy method.” &lt;em&gt;Operations Research&lt;/em&gt; 58 (4 PART 2): 1116–32. &lt;a href=&#34;https://doi.org/10.1287/opre.1100.0843&#34;&gt;https://doi.org/10.1287/opre.1100.0843&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-garciapathways&#34;&gt;
&lt;p&gt;Garcia, C B, and W I Zangwill. 1981. “Pathways to solutions, fixed points, and equilibria. 1981.” Prentice-Hall, Englewood Cliffs, NJ.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Numerical Integration With Sparse Grids</title>
      <link>/post/numerical-integration-with-sparse-grids/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/numerical-integration-with-sparse-grids/</guid>
      <description>


&lt;p&gt;I recently read a paper &lt;span class=&#34;citation&#34;&gt;(Heiss and Winschel &lt;a href=&#34;#ref-heiss2008likelihood&#34;&gt;2008&lt;/a&gt;)&lt;/span&gt; that advocated the use of certain techniques (Sparse Grids, SG henceforth) in numerical integration to calculate likelihood functions, as opposed to using Monte Carlo (MC henceforth) methods for the same. While approximating integrals with MC methods are simpler to implement, they might lead to integral values with considerable simulation error &lt;span class=&#34;citation&#34;&gt;(Skrainka and Judd &lt;a href=&#34;#ref-skrainka2011high&#34;&gt;2011&lt;/a&gt;)&lt;/span&gt;. This post attempts to demonstrate the claim in &lt;span class=&#34;citation&#34;&gt;Skrainka and Judd (&lt;a href=&#34;#ref-skrainka2011high&#34;&gt;2011&lt;/a&gt;)&lt;/span&gt; using two very simple integrals, to which we already know the value. I attempt to compare the outcomes from using MC and SG.&lt;/p&gt;
&lt;p&gt;The integrals I’ll be evaluating are:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34; id=&#34;eq:sumint&#34;&gt;\[\begin{equation}
\int_{-\infty}^{\infty} \left( \sum_{i=1}^{5} x_i \right) dF_{X}   \tag{1} 
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and
&lt;span class=&#34;math display&#34; id=&#34;eq:prodint&#34;&gt;\[\begin{equation}
\int_{-\infty}^{\infty} \left( \prod_{i=1}^{5} x_i^2 \right) dF_{X} \tag{2}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(X = \{x_i\}_{i=1}^{5}\)&lt;/span&gt; is a five dimensional random variable, which is distributed according to the multivariate standard normal:
&lt;span class=&#34;math display&#34;&gt;\[
X \sim N\left( \left[ \begin{array}
{r}
0  \\
0  \\
0  \\
0  \\
0  \\
\end{array}\right], \left[ \begin{array}
{rrrrr}
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0   \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0  \\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0  \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0  \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1  \\
\end{array}\right] \right)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Given the distribution of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;, the values of the integrals above are easily obtained from standard results (the value of &lt;a href=&#34;#eq:sumint&#34;&gt;(1)&lt;/a&gt; is &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; and that of &lt;a href=&#34;#eq:prodint&#34;&gt;(2)&lt;/a&gt; is &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;) respectively.&lt;/p&gt;
&lt;p&gt;I write some utility functions in R to compute the integrands above:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to compute the sum of components of the random vector
s &amp;lt;- function(x)
{
  return(sum(x))
}

#function to compute the square product of the components of the random vector
p &amp;lt;- function(x)
{
  return(prod(x^2))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I now write a function that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simulates a certain number of draws from the distribution of the random variable &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Computes the integrand function using each of these draws as input&lt;/li&gt;
&lt;li&gt;Takes the average of the values computed in the previous step&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This function, in effect, would give us the approximate value of the integral via MC methodology.&lt;/p&gt;
&lt;p&gt;The code is provided below, note that I use the &lt;tt&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/mvtnorm/index.html&#34;&gt;mvtnorm&lt;/a&gt;&lt;/tt&gt; package to create random draws.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mvtnorm)

#Function to calculate the MC approximation for the integral
mc_int &amp;lt;- function(s, n, mu, sigma)
{
  #generate random draws
  x &amp;lt;- rmvnorm(n, mean = mu, sigma = sigma)
  #now get the integral
  mc_int_n &amp;lt;- mean(apply(x, 1, s))
  return(mc_int_n)
}

set.seed(100)
n &amp;lt;- 1000
mc_val &amp;lt;- mc_int(s, n, mu = rep(0,5), sigma = diag(5))
mc_val&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.007150433&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result, 0.00715 is not far off from the true value of &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; at first glance, however, we need to compare this to the result from the SG approach.&lt;/p&gt;
&lt;p&gt;R has a package that generates sparse grids for numerical integration as described in &lt;span class=&#34;citation&#34;&gt;Heiss and Winschel (&lt;a href=&#34;#ref-heiss2008likelihood&#34;&gt;2008&lt;/a&gt;)&lt;/span&gt;, called &lt;tt&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/SparseGrid/index.html&#34;&gt;SparseGrid&lt;/a&gt;&lt;/tt&gt;. We now use the nodes and weights generated from this package to approximate the first integral.
I re-use some of the code provided in the documentation for the &lt;tt&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/SparseGrid/vignettes/SparseGrid.pdf&#34;&gt;SparseGrid&lt;/a&gt;&lt;/tt&gt; package in R.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(SparseGrid)

#generate sparse grids for a 5 dimensional RV with accuracy level 2
sg &amp;lt;- createSparseGrid(type=&amp;#39;KPN&amp;#39;, dimension=5, k=2)


sg_int &amp;lt;- function(func, sg, ...)
{
  gx &amp;lt;- apply(sg$nodes, 1, function(x) {func(x, ...)})
  return(sum(gx * sg$weights))
}

sg_val &amp;lt;- sg_int(s, sg)
sg_val&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result here is exactly 0. In light of this finding, the value obtained from the MC approach, in comparison, is a little off, and tends to show a high variance in output:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(100)

mc_int(s, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.007150433&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(s, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.03162326&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(s, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.1287932&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(s, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.01040134&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(s, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.03798655&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the third case, there is a &lt;span class=&#34;math inline&#34;&gt;\(-12\%\)&lt;/span&gt; error(!) in the value of the computed integral when compared to the result from the SG approach. The SG approach, in addition, shows no such variation in repeated runs, since the grid values and weights are fixed for a given accuracy level and dimension (of the variable being integrated).&lt;/p&gt;
&lt;p&gt;I repeat the calculations for the second integral, as shown below&lt;/p&gt;
&lt;p&gt;MC approach:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(100)
n &amp;lt;- 1000
mc_val &amp;lt;- mc_int(p, n, mu = rep(0,5), sigma = diag(5))
mc_val&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.001089&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SG approach:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#generate sparse grids for a 5 dimensional RV with accuracy level 6
sg &amp;lt;- createSparseGrid(type=&amp;#39;KPN&amp;#39;, dimension=5, k=6)
sg_val &amp;lt;- sg_int(p, sg)
sg_val&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again, the SG approach gives us an exact value (note that the value of &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;, the accuracy level, has gone up, since the integrand is a higher order function). Again, the difference of the results between the two approaches doesn’t seem that large. However, variability of the results from the MC approach is still a concern, as shown below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(100)

mc_int(p, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.001089&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(p, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.4672555&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(p, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.14692&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(p, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.062975&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mc_int(p, n, mu = rep(0,5), sigma = diag(5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9112416&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the second case, there is a roughly &lt;span class=&#34;math inline&#34;&gt;\(53\%\)&lt;/span&gt; (!!) error when compared to the true value of the integral. This variability could be worse with more complicated integrands.&lt;/p&gt;
&lt;p&gt;One suggestion to reduce variability in MC methods is to increase the number of draws, but that would entail a lot of calculations and result in longer runtimes.&lt;/p&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-mvt&#34;&gt;
&lt;p&gt;Genz, Alan, Frank Bretz, Tetsuhisa Miwa, Xuefei Mi, Friedrich Leisch, Fabian Scheipl, and Torsten Hothorn. 2019. &lt;em&gt;mvtnorm: Multivariate Normal and T Distributions&lt;/em&gt;. &lt;a href=&#34;https://CRAN.R-project.org/package=mvtnorm&#34;&gt;https://CRAN.R-project.org/package=mvtnorm&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-heiss2008likelihood&#34;&gt;
&lt;p&gt;Heiss, Florian, and Viktor Winschel. 2008. “Likelihood Approximation by Numerical Integration on Sparse Grids.” &lt;em&gt;Journal of Econometrics&lt;/em&gt; 144 (1): 62–80.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-skrainka2011high&#34;&gt;
&lt;p&gt;Skrainka, Benjamin S, and Kenneth L Judd. 2011. “High Performance Quadrature Rules: How Numerical Integration Affects a Popular Model of Product Differentiation.” &lt;em&gt;Available at SSRN 1870703&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
